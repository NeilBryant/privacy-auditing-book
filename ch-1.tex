\chapter{Introduction}
Examples in this book should run on Windows, Macintosh and Linux-based
systems. The code was largely developed on a Mac, which is similar to
Linux. 

\section{Conventions used in this book}
In general this book follows Wikipedia conventions:


\subsection{Radix}
Numbers are generally assumed to be in base 10 unless otherwise
specified. Binary digits will be suffixed with a ``b''' octal
is indicated with a leading ``0'' as in the case in most programming
languages; hexadecimal numbers will have a suffix of an ``h'' in text
but may be prefixed with |0x| or |\x|. Unfortunately there are
exceptions which must be inferred from context. For example, hex dumps
and cryptographic hashes are always presented as unadorned hexadecimal
digits. Examples are shown in \tabref{nomen}.

\begin{table}
\begin{tabular}{rlcrl}
     &              &         & Decimal  \\
Base & Nomenclature & Example & Equivalent & Usage \\
\hline
2  & Binary      & \tt 10101111b & 175  & Text\\
\hline
8  & Octal       & \tt  0377    & 255  & Text and code\\
   &             & \tt \\377    & 255  & Code\\
10 & Decimal     & 1234      & 1234 & Text and code\\
16 & Hexadecimal & \tt DEADBEEFh & 3,735,928,559 & text \\
   &             & \tt 0xFF      & 255  & Output \\
   &             & |\xFF|    & 255  & Python code\\
\end{tabular}
\caption{Examples of numbers in various bases used in this book.}
\end{table}

\subsubsection{Units}


\subsection{SI and IEC Multipliers}
% \note{1MB = 1,000,000 bytes}
% \note{1MiB = 1,048,576 bytes}

Today there are two standards in computing for representing sizes of
files, storage systems, and memory banks: SI (the International System
of Units) decimal prefixes and IEC (International Electrotechnical
Commission) binary prefixes. This situation is confusing because until
recently the SI prefix names \emph{kilo}, \emph{mega} and \emph{giga} were commonly used
for both decimal and binary notation, the correct multiplier being
inferred from usage. Today there is an effort underway to clarify
usage. This section describes correct usage and provides hints for
determining when usage is incorrect.

SI decimal prefixes are commonly used to represent metric
quantities. For example, the SI prefix \emph{giga} multiplies the value that follows by
$10^9$; thus a gigabyte (GB) is
$10^9=1,000,000,000$ bytes. (Confusingly, this is called a billion bytes
in the US but a thousand million bytes in Great Britain, although the
Oxford Dictionary English (British Edition) that ships with MacOS 10.8
calls such usage ``dated.'')

The IEC prefix \emph{gibi} multiples the value following by $2^{30}$. A \emph{gibibyte}
(GiB) is thus $2^{30}=1,073,741,824$ bytes. This has been proper usage
since 1999 when the IEC adopted standard 60027-2 for binary prefixes.

The confusion dates back to the early days of computing, when the ``K''
and ``M'' prefixes were commonly used to mean 1,024 and 1,048,576
when describing memory systems but 1,000 and 1,000,000 when
describing mass storage systems. The difference in terminology resulted
from the way that these systems were addressed. Memory was addressed
by a series of binary address lines, while electromechanical drums and
disks were addressed by specifying a head, a track, and then counting
sector numbers: such numbers only map to even powers-of-two when the
number of heads, tracks and sectors are also even powers-of-two, and
this is rarely the case due to manufacturing concerns.

For much of computing history the correct sense of Ks and Ms could be
inferred from context and, in any event, the difference between 1000
and 1024 wasn't all that significant.

The difference in interpretation became an issue in the 1990s as the
number of people using computers mushroomed and as the commonly used
prefixes went from Ks to Ms and then Gs, resulting in a larger
divergence between the power-of-two measurement and the corresponding
power-of-ten measurement. The IEC prefixes were proposed in
1996\cite{iec:1996},
published as an international standard in 1999, and adopted by the
International Standards organization with the addition of prefixes for
describing exbi (Ei=$2^{60}$), zebi (Zi=$2^{70}$) and yobi (Yi=$2^{80}$) byte
quantities in 2008\cite{iec:80000-13:2008}.  

Despite this standardization effort, today we live in a somewhat
confusing world in which so-called ``4GB'' DRAM modules 
store precisely 4,294,967,296 bytes
but ``4GB'' microSD cards sold for cell
phones store 4,000,000,000 bytes. Even more confusing, the DRAM
module may have four ($2^{2}$) chips, each storing 1073741824
($2^{30}$) bytes each, while the microSD card may two million flash
pages, each with 4096 bytes of usable storage, but present that
information as precisely 7,812,500 logical 512-byte blocks.  These
differences are the result of different operational requirements for
the two kinds of memory, resulting in different kinds of access
electronics, different kinds of software, and different economics. 

It is likely that the IEC binary prefixes will show increased use
with time. Therefore this book uses them to describe block size and
sector size, since they are typically multiples of 512 ($2^9$), but 
SI decimal prefixes are used to describe disk sizes, since that is the way
the devices are sold to consumers.


\section{Python}
This book makes extensive use of the Python programming language for
its examples. All of the examples are tested under Python~3.3,
although Python~2.7 will work with most of the demonstration programs
as well.  This section describes specific aspects of the Python
programming language that are important in our examples and that may
be missed in an introductory Python programming class.

\subsection{Reading and Writing Files: Binary vs.\ Text}

When a Python program opens a file that file may be opened in one of
two modes: \emph{text} or \emph{binary}.  When opened as text, Python
assumes that the files contain text characters that have been encoded
with an appropriate codec---for example, that they are Unicode files
coded as UTF-8. Assuming such a codec qcan cause problems when reading
binary data, since many binary combinations do not represent valid
characters. To avoid this problem, files will normally be opened in
binary mode. This is done by opening files with method
|open(filename,"rb")|.

\subsection{Python's struct.unpack}
Much of the information on computers is stored as binary encoded
values. Such values can be easily read and written using python's
|struct.unpack| method, which reads a binary structure and returns a
python tuple of the decoded values.  

The binary structure is decoded using a \emph{format
  specification}. For example, this Python fragment will print the
decimal value of the hex string DEADBEEFh:

\lstinputlisting[caption=A program to print the text value of the
  string DEADBEEFh]{intro/deadbeef.py}


\subsection{Path Delimiter}
Windows uses the backslash (|\|) as a path delimiter, while Unix
systems use the forward slash (|/|). In general this is not a problem,
because Python run on Windows will treat either slash as a path
delimiter. So in general, this book will use the forward slash as a
path delimiter, even for code that runs on Windows-based computers.

\subsection{Accessing Raw Devices}

A ``raw'' device is a device file that can be opened by user programs
like a normal file but reads and writes are sent directly to the
underlying physical device. Typically access to the raw disk devices 
requires administrative privileges, since access to the raw device
bypasses the computer's operating system.

To access the physical drives on a Windows computer open the hidden
physical drives |\\.\PhysicalDrive0| through
|\\.\PhysicalDriveNN|. To open the physical drive for reading use use
mode |rb|, for writing use the ``updating'' mode |rb+|. List the
physical drives on your Windows system with the command:

\begin{code}
c:\ (@ \hl{wmic diskdrive list brief /format:list} @)
\end{code}

Unix-based systems associate two pseudo-files in the |/dev/| directory with
each physical device; additional pseudo-files map to disk
partitions. Macs use |/dev/diskNN| for block devices and
|/dev/rdiskNN| for raw devices. Partitions are identified by appending
a |sJ|, where |J| is the partition number.  List the physical drives
on a Mac with the command:

\begin{code}
$ (@ \hl{ls -l /dev/disk*} @)
\end{code}
%$

Linux systems name block devices |/dev/sdA| where |A| is a letter |a|
through the highest device letter; partitions are identified with an
appended letter. Modern Linux systems also map physical devices in
additional locations, including the directory |/dev/disk/by-uuid/| for
a list of drives by UUID, |/dev/disk/by-partuuid| for partitions by
UUID, |/dev/disk/by-path| for their location on the PCI or SCSI bus,
and |/dev/disk/by-id| for device IDs. Linux systems may also map
block devices in the |/sys/dev/block/| and character devices in
|/sys/dev/char/|. List the physical drives
on a Mac with the command:

\begin{code}
$ (@ \hl{ls -l /dev/sd*} @)
\end{code}
%$


\subsection{Making Graphs}
There are a large and growing number of producing graphical displays
from Python. This book uses the Python library matplotlib for data
visualization and graphiviz.



On Windows, install matplotlib for Python 3.3 with:

On MacOS, install matplotlib for Python 3.3 with:
\begin{code}
$ (@ \hl{sudo port install py33-matplotlib} @)
\end{code}
%$


\section{Open Source Forensic Tools}

\subsection{SleuthKit}

SleuthKit is...

precompiled binaries for
Windows. http://sourceforge.net/projects/sleuthkit/files/sleuthkit/4.0.2/
  Download sleuthkit-win32-4.0.2.zip and uncompress the files into
  |c:\sleuthkit-win32-4.0.2|




TK

\subsection{WireShark and tcpflow}

TK

\subsection{Bulk Extractor}

TK

\section{Setting Up your Computer}
This section provides recommendations for setting up your computer to
make the most of the examples and exercises in this book. Remember,
these are \emph{recommendations,} not requirements.

\subsection{Setting up Windows}
Windows users should download the most recent version of Python 3 from
\url{http://www.python.org/getit}. Use the \emph{Windows X86-64 MSI
  Installer} if you have a 64-bit system and a \emph{Windows x86 MSI
  Installer} for 32-bit system. Although the 32-bit version will work
on a 64-bit system, 32-bit programs running on a 64-bit system are
presented with a slightly incorrect view of the computer's file
system, which can be confusing in some instances.\footnote{Microsoft
  uses the term Windows on Windows 64, or WOW64, to describe the
  process of running 32-bit applications on 64 bit Windows. For a
  complete discussion, search for WOW64 on MSDN or Wikipedia.}

Once you have installed Python, you may wish to modify your Windows
console so that it has 132 rows of text and 9999 lines of
scrollback. You can do this by running the |cmd.exe| program from the
Start menu then right-clicking on the window's titlebar and selecting
the ``Properties'' menu, as shown in \figref{intro/windows-console}.

Windows users may also wish to become familiar with the Windows
PowerShell, a replacement for |cmd.exe|.

\sgraphic{intro/windows-console}{Setting your Windows console for 132
  rows of text and 9999 lines of scrollback will improve the usability
  of many text-based commands.}

\subsection{Linux}
On Linux systems you may need to explicitly install Python 3. Do so on
Fedora by typing:

\begin{code}
$ (@ \hl{sudo yum install python3} @) 
\end{code} 
% $

\subsection{MacOS}

For Mac systems we recommend installing Python 3 with the MacPorts
system. Download MacPorts from \url{http://macports.org/} and then type:

\begin{code}
$ (@ \hl{sudo port install python33} @) 
\end{code} 
% $

\section{Other References}
\subsection{Books}
\cite{carrier-file-systems}
\subsection{Articles}
