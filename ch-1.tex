\chapter{Introduction}
\section{What is Privacy Auditing?}
\section{What is Computer Forensics?}
\section{What are Computer Forensics Tools?}
\section{What is Personally Identifiable Information?}
\subsection{Legal definitions}
\subsection{Practical definitions}
\subsection{Practical Concerns}
\subsubsection{Reuse of identifiers - at the same time, at different times}
\subsubsection{Shared IDs}
\subsubsection{specificity of identifiers; birthday problem}
\subsubsection{IP addresses}
\subsubsection{Identifiers: IPv4, IPv6, Mobile ID, SIM cards, Phone \#s, email addressses}
\subsection{GUIDs and identifiers}
\subsection{What is ``Unique''}
\section{Unnoticed data leakage - why it's a problem}
\subsection{Example: Geolocation Data in JPEGs}
  - Show how to find where a photo was taken with Preview on a Mac. 
\subsection{Example: Blacked out text in PDFs}
EEOC

Senate committee

\section{Detecting data leakage as an experimental science}
\subsection{Detecting data leakage attempts to prove a negative}


Examples in this book should run on Windows, Macintosh and Linux-based
systems. The code was largely developed on a Mac, which is similar to
Linux. 

\section{Conventions used in this book}
In general this book follows \emph{Wikipedia Manual of
  Style}\footnote{\url{http://en.wikipedia.org/wiki/Wikipedia:Manual_of_Style}}
and specifically the Computer
Science\footnote{\url{http://en.wikipedia.org/wiki/Wikipedia:WikiProject_Computer_science/Manual_of_style}}
  and
  Computing\footnote{\url{http://en.wikipedia.org/wiki/Wikipedia:Manual_of_Style/Computing}}
  sections. Specific conventions useful in understanding this book are
  described below.

\subsection{Fonts}

Text in this book is generally typeset in the serif font that you are
now reading. The fixed-width courier font is used for programs,
computer input and output, as well as for numbers that might
reasonably be expected to be constants in a computer program. Thus,
the Earth is 150 million kilometers (150 Gm) from the sun, but a
traditional disk sector has |512| bytes (|512|~B).

\subsection{Radix}
Numbers are generally assumed to be in base 10 unless otherwise
specified. Binary digits will be suffixed with a |b|; octal
is indicated with a leading |0| as in the case in most programming
languages; hexadecimal numbers will have a suffix of an |h| in text
but may be prefixed with |0x| or |\x|. Unfortunately there are
exceptions which must be inferred from context. For example, hex dumps
and cryptographic hashes are always presented courier as unadorned hexadecimal
digits. Examples are shown in \tabref{nomen}.

\begin{table}
\begin{tabular}{rlcrl}
     &              &         & Decimal  \\
Base & Nomenclature & Example & Equivalent      & Usage \\
\hline
2  & Binary      &  |10101111b|& 175            & Text\\
\hline
8  & Octal       &  |0377|     & 255            & Text and code\\
8  & Octal       &  |\377|     & 255            & Code\\
10 & Decimal     &  |1234|     & 1234           & Text and code\\
16 & Hexadecimal &  |DEADBEEFh|& 3,735,928,559  & text \\
   &             &  |0xFF|     & 255            & Output \\
   &             &  |\xFF|     & 255            & Python code\\
\end{tabular}
\caption{Examples of numbers in various bases used in this book.}
\end{table}

\subsubsection{Units}

Natural phenomena discussed in this book are described in Metric
units. Manufactured objects are described in either Metric units or
United States customary units, depending on the system of measurements
that was used to design and produce the object, with approximate
metric units indicated as appropriate. Thus, this book
discusses 5.25-inch (133mm) floppy disks.

\subsection{SI and IEC Multipliers}\label{sec:si-and-iec}
% \note{1MB = 1,000,000 bytes}
% \note{1MiB = 1,048,576 bytes}

Today there are two standards in computing for representing sizes of
files, storage systems, and memory banks: SI (the International System
of Units) decimal prefixes and IEC (International Electrotechnical
Commission) binary prefixes. This situation is confusing because until
recently the SI prefix names \emph{kilo}, \emph{mega} and \emph{giga} were commonly used
for both decimal and binary notation, the correct multiplier being
inferred from usage. Today there is an effort underway to clarify
usage. This section describes correct usage and provides hints for
determining when usage is incorrect.

SI decimal prefixes are commonly used to represent metric
quantities. For example, the SI prefix \emph{giga} multiplies the value that follows by
$10^9$; thus a gigabyte (GB) is
$10^9=1,000,000,000$ bytes. (Confusingly, this is called a billion bytes
in the US but a thousand million bytes in Great Britain, although the
Oxford Dictionary English (British Edition) that ships with MacOS 10.8
calls such usage ``dated.'')

The IEC prefix \emph{gibi} multiples the value following by $2^{30}$. A \emph{gibibyte}
(GiB) is thus $2^{30}=1,073,741,824$ bytes. This has been proper usage
since 1999 when the IEC adopted standard 60027-2 for binary prefixes.

The confusion dates back to the early days of computing, when the ``K''
and ``M'' prefixes were commonly used to mean 1,024 and 1,048,576
when describing memory systems but 1,000 and 1,000,000 when
describing mass storage systems. The difference in terminology resulted
from the way that these systems were addressed. Memory was addressed
by a series of binary address lines, while electromechanical drums and
disks were addressed by specifying a head, a track, and then counting
sector numbers: such numbers only map to even powers-of-two when the
number of heads, tracks and sectors are also even powers-of-two, and
this is rarely the case due to manufacturing concerns.

For much of computing history the correct sense of Ks and Ms could be
inferred from context and, in any event, the difference between 1000
and 1024 wasn't all that significant.

The difference in interpretation became an issue in the 1990s as the
number of people using computers mushroomed and as the commonly used
prefixes went from Ks to Ms and then Gs, resulting in a larger
divergence between the power-of-two measurement and the corresponding
power-of-ten measurement. The IEC prefixes were proposed in
1996\cite{iec:1996},
published as an international standard in 1999, and adopted by the
International Standards organization with the addition of prefixes for
describing exbi (Ei=$2^{60}$), zebi (Zi=$2^{70}$) and yobi (Yi=$2^{80}$) byte
quantities in 2006\cite{iec:80000-13:2008}.  

Despite this standardization effort, today we live in a somewhat
confusing world in which so-called ``4GB'' DRAM modules 
store precisely 4,294,967,296 bytes
but ``4GB'' microSD cards sold for cell
phones store 4,000,000,000 bytes. Even more confusing, the DRAM
module may have four ($2^{2}$) chips, each storing 1073741824
($2^{30}$) bytes each, while the microSD card may two million flash
pages, each with 4096 bytes of usable storage, but present that
information as precisely 7,812,500 logical 512-byte blocks.  These
differences are the result of different operational requirements for
the two kinds of memory, resulting in different kinds of access
electronics, different kinds of software, and different economics. 

It is likely that the IEC binary prefixes will show increased use
with time. Therefore this book uses them to describe block size and
sector size, since they are typically multiples of 512 ($2^9$), but 
SI decimal prefixes are used to describe disk sizes, since that is the way
the devices are sold to consumers.


\section{Setting Up your Computer}
This section provides recommendations for setting up your computer to
make the most of the examples and exercises in this book. Remember,
these are \emph{recommendations,} not requirements.

Once you have installed Python, you may wish to modify your Windows
console so that it has 132 rows of text and 9999 lines of
scrollback. You can do this by running the |cmd.exe| program from the
Start menu then right-clicking on the window's titlebar and selecting
the ``Properties'' menu, as shown in \figref{intro/windows-console}.

Windows users may also wish to become familiar with the Windows
PowerShell, a replacement for |cmd.exe|.

\sgraphic{intro/windows-console}{Setting your Windows console for 132
  rows of text and 9999 lines of scrollback will improve the usability
  of many text-based commands.}

\subsection{MacOS}

For Mac systems we recommend installing Python 3 with the MacPorts
system. Download MacPorts from \url{http://macports.org/} and then type:

\begin{code}
$ (@ \hl{sudo port install python33} @) 
\end{code} 
% $



\section{Python}
This book makes extensive use of the Python programming language for
its examples. All of the examples are tested under Python~3.3,
although Python~2.7 may work with most of the demonstration programs
as well.  This section describes specific aspects of the Python
programming language that are important in our examples and that may
be missed in an introductory Python programming class.

\subsection{Reading and Writing Files: Binary vs.\ Text}

When a Python program opens a file that file may be opened in one of
two modes: \emph{text} or \emph{binary}.  When opened as text, Python
assumes that the files contain text characters that have been encoded
with an appropriate codec---for example, that they are Unicode files
coded as UTF-8. Assuming such a codec qcan cause problems when reading
binary data, since many binary combinations do not represent valid
characters. To avoid this problem, files will normally be opened in
binary mode. This is done by opening files with method
|open(filename,"rb")|.

\subsection{Python's struct.unpack}
Much of the information on computers is stored as binary encoded
values. Such values can be easily read and written using python's
|struct.unpack| method, which reads a binary structure and returns a
python tuple of the decoded values.  

The binary structure is decoded using a \emph{format
  specification}. For example, this Python fragment will print the
decimal value of the hex string DEADBEEFh:

\lstinputlisting[caption=A program to print the decimal value of the hexadecimal number \texttt{DEADBEEFh}]{intro/deadbeef.py}


\subsection{Path Delimiter}
Windows uses the backslash (|\|) as a path delimiter, while Unix
systems use the forward slash (|/|). In general this is not a problem,
because Python run on Windows will treat either slash as a path
delimiter. So in general, this book will use the forward slash as a
path delimiter, even for code that runs on Windows-based computers.

\subsection{Accessing Raw Devices}

A ``raw'' device is a device file that can be opened by user programs
like a normal file but reads and writes are sent directly to the
underlying physical device. Typically access to the raw disk devices 
requires administrative privileges, since access to the raw device
bypasses the computer's operating system.

To access the physical drives on a Windows computer open the hidden
physical drives |\\.\PhysicalDrive0| through
|\\.\PhysicalDriveNN|. To open the physical drive for reading use use
mode |rb|, for writing use the ``updating'' mode |rb+|. List the
physical drives on your Windows system with the command:

\begin{code}
c:\ (@ \hl{wmic diskdrive list brief /format:list} @)
\end{code}

Unix-based systems associate two pseudo-files in the |/dev/| directory with
each physical device; additional pseudo-files map to disk
partitions. Macs use |/dev/diskNN| for block devices and
|/dev/rdiskNN| for raw devices. Partitions are identified by appending
a |sJ|, where |J| is the partition number.  List the physical drives
on a Mac with the command:

\begin{code}
$ (@ \hl{ls -l /dev/disk*} @)
\end{code}
%$

Linux systems name block devices |/dev/sdA| where |A| is a letter |a|
through the highest device letter; partitions are identified with an
appended letter. Modern Linux systems also map physical devices in
additional locations, including the directory |/dev/disk/by-uuid/| for
a list of drives by UUID, |/dev/disk/by-partuuid| for partitions by
UUID, |/dev/disk/by-path| for their location on the PCI or SCSI bus,
and |/dev/disk/by-id| for device IDs. Linux systems may also map
block devices in the |/sys/dev/block/| and character devices in
|/sys/dev/char/|. List the physical drives
on a Mac with the command:

\begin{code}
$ (@ \hl{ls -l /dev/sd*} @)
\end{code}
%$


\subsection{Making Graphs}
There are a large and growing number of producing graphical displays
from Python. This book uses the Python library matplotlib for data
visualization and graphiviz.


\subsection{Python3 on Windows}
Windows users should download the most recent version of Python 3 from
\url{http://www.python.org/getit}. Use the \emph{Windows X86-64 MSI
  Installer} if you have a 64-bit system and a \emph{Windows x86 MSI
  Installer} for 32-bit system. Although the 32-bit version will work
on a 64-bit system, 32-bit programs running on a 64-bit system are
presented with a slightly incorrect view of the computer's file
system, which can be confusing in some instances.\footnote{Microsoft
  uses the term Windows on Windows 64, or WOW64, to describe the
  process of running 32-bit applications on 64 bit Windows. For a
  complete discussion, search for WOW64 on MSDN or Wikipedia.}


On Windows, install matplotlib for Python 3.3 with:

\subsection{Python3 on Linux}
On Linux systems you may need to explicitly install Python 3. Do so on
Fedora by typing:

\begin{code}
$ (@ \hl{sudo yum install python3} @) 
\end{code} 
% $

\subsection{Python3 on Macintosh}
On MacOS, install matplotlib for Python 3.3 with:
\begin{code}
$ (@ \hl{sudo port install py33-matplotlib} @)
\end{code}
%$

\section{Open Source Forensic Tools}

\subsection{Sleuth Kit}

Sleuth Kit is an open source digital forensics toolkit for extracting
files from disk images. Sleuth Kit understands a variety of disk image
formats, partitioning schemes, and file systems. With Sleuth Kit, you can can recover
both allocated files and files that have been deleted directly from a
disk image, without having to ``mount'' the disk image by the host
operating system. An added advantage of Sleuth Kit is that it runs on
Windows, Linux, and Macintosh systems, allowing you to access data
from disk images even if your underlying operating system does not
understand the format.

The Sleuth Kit website\footnote{http://sleuthkit.org} has information
on Sleuth Kit, Autopsy (a graphical interface for SleuthKit), the
Sleuth Kit Hadoop Framework (for processing large numbers of hard
drives in a cloud computing environment), and other tools. 
Precompiled binaries for

\subsubsection{Sleuth Kit under Windows}
Windows users should download pre-compiled Sleuth Kit binaries from Source
Forge.\footnote{\url{http://sourceforge.net/projects/sleuthkit/files/sleuthkit/4.0.2/}}
and install them in into |c:\sleuthkit|.

\subsubsection{Sleuth Kit under Linux}

\subsubsection{Sleuth Kit under Macintosh}

\subsection{WireShark and tcpflow}

\subsubsection{WireShark and tcpflow on Windows}
\subsubsection{WireShark and tcpflow on Linux}
\subsubsection{WireShark and tcpflow on Macintosh}

\subsection{Bulk Extractor}

\subsubsection{Bulk Extractor on Windows}
\subsubsection{Bulk Extractor on Linux}
\subsubsection{Bulk Extractor on Macintosh}

<<<<<<< HEAD
\sgraphic{intro/windows-console}{Setting your Windows console for 132
  rows of text and 9999 lines of scrollback will improve the usability
  of many text-based commands.}

\subsubsection{Hex Dumps under Windows}

Notepad++ / Install a hex editor plugin

\subsection{Linux}
On Linux systems you may need to explicitly install Python 3. Do so on
Fedora by typing:

\begin{code}
$ (@ \hl{sudo yum install python3} @) 
\end{code} 
% $

\subsubsection{Hex Dumps under Linux}

\subsection{MacOS}
=======
\section{Other References}
\subsection{Books}\label{section:books}
The following books are referenced in this book:
>>>>>>> 6016c5bf76ea49c5b40270cce00bff8b00a967b7

\printbibliography[heading=bibempty,type=book]


\cite{carrier-file-systems}
\subsection{Articles}
