\chapter{Introduction}
something about the introduction
\section{Python used in this book}
This book makes extensive use of the Python programming language for
its examples. All of the examples are tested under Python~3.3,
although Python~2.7 will work with most of the demonstration programs
as well.

Examples in this book should run on Windows, Macintosh and Linux-based
systems. The code was largely developed on a Mac, which is similar to
Linux. For differences between Windows, Mac and Linux, see
\secref{os-differences}.


\subsection{Getting Python 3}
\subsubsection{Windows}
Windows users should download the most recent version of Python 3 from
\url{http://www.python.org/getit}. Use the \emph{Windows X86-64 MSI
  Installer} if you have a 64-bit system and a \emph{Windows x86 MSI
  Installer} for 32-bit system. Although the 32-bit version will work
on a 64-bit system, 32-bit programs running on a 64-bit system are
presented with a slightly incorrect view of the computer's file
system, which can be confusing in some instances.\footnote{Microsoft
  uses the term Windows on Windows 64, or WOW64, to describe the
  process of running 32-bit applications on 64 bit Windows. For a
  complete discussion, search for WOW64 on MSDN or Wikipedia.}

\subsubsection{Linux}
On Linux systems you may need to explicitly install Python 3. Do so on
Fedora by typing:

\texttt{\$ \textbf{sudo yum install python3}}


\subsubsection{MacOS}

\subsection{Python Binary files}
Python files can be opened as \emph{text} or as \emph{binary}. When
opened as text, Python assumes that the files contained text
characters that have been encoded with an appropriate codec. This can
cause problems when reading binary data, since many binary
combinations do not represent valid characters. To avoid this problem,
files will normally be opened in binary mode. This is done by opening
files with method |open(filename,"rb")|.

\subsection{Python struct.unpack}
Much of the information on computers is stored as binary encoded
values. Such values can be easily read and written using python's
|struct.unpack| method, which reads a binary structure and returns a
python tuple of the decoded values.  

The binary structure is decoded using a \emph{format
  specification}. For example, this Python fragment will print the
decimal value of the hex string DEADBEEFh:

\lstinputlisting[caption=A program to print the text value of the
  string DEADBEEFh]{intro/deadbeef.py}


\section{Differences between Windows, Macintosh and Linux}

This section lists key differences between the operating systems that
can run Python. 

It is our experience that most students and most forensics
practitioners in the US are using versions of Microsoft Windows
(mostly XP and 7), while most forensics developers and researchers are
using either MacOS or Linux. Although these three operating systems
have different ways of performing many of the same functions, many
high-level languages attempt to mask the differences and provide a
common environment to allow code portability. 
through of as one OS and L

\subsection{Path Delimiter}
Windows uses the backslash (|\|) as a path delimiter, while Unix
systems use the forward slash (|/|). In general this is not a problem,
because Python run on Windows will treat either slash as a path
delimiter.

\subsection{Physical and Raw Disk Devices}
A ``raw'' device is a device file that can be opened by user programs
like a normal file but reads and writes are sent directly to the
underlying physical device. Typically access to the raw disk devices 
requires administrative privileges, since access to the raw device
bypasses the computer's operating system.

Windows uses a variety of hidden file names to access raw devices,
including the legacy DOS devices (CON, PRN, NUL, etc.) 
Physical drives are accessed as |\\.\PhysicalDrive0| through
|\\.\PhysicalDriveNN|. To open the physical drive for reading use use
mode |rb|, for writing use the ``updating'' mode |rb+|.

Unix-based systems associate two pseudo-files in the |/dev/| directory with
each physical device; additional pseudo-files map to disk
partitions. Macs use |/dev/diskNN| for block devices and
|/dev/rdiskNN| for raw devices. Partitions are identified by appending
a |sJ|, where |J| is the partition number.

Linux systems name block devices |/dev/sdA| where |A| is a letter |a|
through the highest device letter; partitions are identified with an
appended letter. Modern Linux systems also map physical devices in
additional locations, including the directory |/dev/disk/by-uuid/| for
a list of drives by UUID, |/dev/disk/by-partuuid| for partitions by
UUID, |/dev/disk/by-path| for their location on the PCI or SCSI bus,
and |/dev/disk/by-id| for device IDs. Linux systems may also map
block devices in the |/sys/dev/block/| and character devices in |/sys/dev/char/|.


\section{Conventions used in this book}
In general this book follows Wikipedia conventions:


\subsection{Radix}
Numbers are generally assumed to be in base 10 unless otherwise
specified. Binary digits will be suffixed with a ``b''' octal
is indicated with a leading ``0'' as in the case in most programming
languages; hexadecimal numbers will have a suffix of an ``h'' in text
but may be prefixed with |0x| or |\x|. Unfortunately there are
exceptions which must be inferred from context. For example, hex dumps
and cryptographic hashes are always presented as unadorned hexadecimal
digits. Examples are shown in \tabref{nomen}.

\begin{table}
\begin{tabular}{rlcrl}
     &              &         & Decimal  \\
Base & Nomenclature & Example & Equivalent & Usage \\
\hline
2  & Binary      & 10101111b & 175  & Text\\
8  & Octal       & 0377      & 255  & Text and code\\
                 & |\377|    & 255  & Code\\
10 & Decimal     & 1234      & 1234 & Text and code\\
16 & Hexadecimal & DEADBEEFh & 3,735,928,559 & text \\
                 & 0xFF      & 255  & Output \\
                 & |\xFF|    & 255  & Python code\\
\end{tabular}
\caption{Examples of numbers in various bases used in this book.}
\end{table}

\subsubsection{Units}


\subsection{Multipliers}
\marginpar{1MB = 1,000,000 bytes}
\marginpar{1MiB = 1,048,576 bytes}

Today there are two standards in computing for representing sizes of
files, storage systems, and memory banks: SI (the International System
of Units) decimal prefixes and IEC (International Electrotechnical
Commission) binary prefixes. This situation is confusing because until
recently the SI prefix names \emph{kilo}, \emph{mega} and \emph{giga} were commonly used
for both decimal and binary notation, the correct multiplier being
inferred from usage. Today there is an effort underway to clarify
usage. This section describes correct usage and provides hints for
determining when usage is incorrect.

SI decimal prefixes are commonly used to represent metric
quantities. For example, the SI prefix \emph{giga} multiplies the value that follows by
$10^9$; thus a gigabyte (GB) is
$10^9=1,000,000,000$ bytes. (Confusingly, this is called a billion bytes
in the US but a thousand million bytes in Great Britain, although the
Oxford Dictionary English (British Edition) that ships with MacOS 10.8
calls such usage ``dated.'')

The IEC prefix \emph{gibi} multiples the value following by $2^{30}$. A \emph{gibibyte}
(GiB) is thus $2^{30}=1,073,741,824$ bytes. This has been proper usage
since 1999 when the IEC adopted standard 60027-2 for binary prefixes.

The confusion dates back to the early days of computing, when the ``K''
and ``M'' prefixes were commonly used to mean 1,024 and 1,048,576
when describing memory systems but 1,000 and 1,000,000 when
describing mass storage systems. The difference in terminology resulted
from the way that these systems were addressed. Memory was addressed
by a series of binary address lines, while electromechanical drums and
disks were addressed by specifying a head, a track, and then counting
sector numbers: such numbers only map to even powers-of-two when the
number of heads, tracks and sectors are also even powers-of-two, and
this is rarely the case due to manufacturing concerns.

For much of computing history the correct sense of Ks and Ms could be
inferred from context and, in any event, the difference between 1000
and 1024 wasn't all that significant.

The difference in interpretation became an issue in the 1990s as the
number of people using computers mushroomed and as the commonly used
prefixes went from Ks to Ms and then Gs, resulting in a larger
divergence between the power-of-two measurement and the corresponding
power-of-ten measurement. The IEC prefixes were proposed in
1996\cite{iec:1996},
published as an international standard in 1999, and adopted by the
International Standards organization with the addition of prefixes for
describing exbi (Ei=$2^{60}$), zebi (Zi=$2^{70}$) and yobi (Yi=$2^{80}$) byte
quantities in 2008\cite{iec:80000-13:2008}.  

Despite this standardization effort, today we live in a somewhat
confusing world in which 4GB memory sticks sold as system RAM can
store 4,294,967,296 bytes of data but 4GB microSD cards sold for cell
phones are only warranted to store 4,000,000,000 bytes of
data. However, since those 4 billion bytes are organized in 512-byte
logical sectors, the microSD card actually has roughly 7,812,500
sectors available to store user data. This number that  doesn't make much sense technically, but
makes a great deal of sense from an economic point of view. On a
typical flash chip a significant number of the storage cells do not
function properly: these bad cells are mapped out of the logical
address space during the manufacturing process. There will be more
chips with 7.8 million functioning sectors than with 8 million. 

It is likely that the IEC binary prefixes will show increased use
with time. Therefore this book uses them to describe block size and
sector size, since they are typically multiples of 512 ($2^9$), but 
SI decimal prefixes are used to describe disk sizes, since that is the way
the devices are sold to consumers.



