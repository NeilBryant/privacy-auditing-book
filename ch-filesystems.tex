

\chapter{Finding Hidden Data in File Systems}
As a computer user you are no doubt familiar with files. This chapter
looks in detail at how files are stored on \emph{mass storage devices}
such as hard drives, USB memory sticks, and camera cards. It shows how
two popular file systems store information in files and directories,
and how the information on the media changes when the user attempts to
delete a file.

As we will see, many file systems retain a significant amount of
potentially sensitive information even after a file is deleted. This
retention isn't \emph{inherent}, but it is \emph{common}. That is,
system designers could create file systems that erase all traces of
information when files are deleted, but they generally don't, because
overwriting deleted data has real costs in terms of performance,
battery consumption, and increased code complexity.

Computer forensic tools such as Sleuth Kit take advantage of this
\emph{residual information} that's left behind after a file deletion
and make it possible to recover deleted files---provided that the data
has not been overwritten by new information. Thus, the ability to
recover files from a drive depends on how the drive
was \emph{after} the file or files were first deleted.

In order to understand how information is recovered from a drive,
we'll need to learn how files and directories are stored in the first
place. We'll also learn how to construct an experiment that you can
use to determine if data is left behind or not. That's useful for
analyzing new file systems that are not implemented by existing
forensic tools.

Tools used in this chapter:
\begin{itemize}
\item Hex dump tool
\item Python
\item SleuthKit 
\end{itemize}

\section{Disks, Sectors, Files and File Systems}
This section describes how files are stored on mass storage devices
such as flash cards, solid state drives and spinning hard drives. 


\subsection{Mass Storage Systems: Organization and Addressing}

Mass storage systems don't store files. Instead, they store blocks of
bytes (sometimes called \emph{sectors}). These blocks are invariably
sized as an even power of 2. In the 1990s most hard drives had a block
size of 512~B; modern drives (both SSD and HD) have a block size of
4~KiB.\footnote{Compact Discs (CDs) have a block size of 2048~B.}
A 1~TB drive therefore has approximately 250 million 4~KiB
blocks. 

Each block on the media is referenced by a distinct number
called a \emph{logical block address} (LBA). These drives are
\emph{random access}, meaning that the computer can read or write any
block in any order, although it is invariably faster to read or write
blocks multiple blocks at a time in numeric order.
\index{LBA|see {Logical Block Address}}
\index{Logical Block Address}

Users don't see blocks of bytes when they take an SD card out of a
camera and try to read the contents on their laptop: they see folders
and files. The \emph{file system} is the part of the computer's
operating system that implements the \emph{file abstraction layer},
taking the \emph{file names} used by people and application programs,
and mapping them to specific numbered blocks of data on the mass
storage device. (``Linux contains an NTFS \emph{file system} so that
it can read hard drives created on Windows-based computers.'')
Confusingly, the phrase \emph{file system} can also be used to
describe a specific set of sectors on a specific piece of
media. (``The \emph{file system} was damaged when the computer
crashed.'')
 
The file system provides an API that allows program to read and write
the contents of files, which ultimately results in the contents of
specific disk sectors being copied into regions of memory specified by
the application. File systems also provide a facility for grouping
multiple files into sets called \emph{folders} or
\emph{directories}. Finally there are provisions for creating and
deleting files, renaming files, moving files from one directory to
another, creating and deleting directories, and so on. Each of these
changes to the file system structure must eventually be reflected by
changes to sectors on the mass storage device.

Most modern computers define a \emph{file} to be a sequence of zero or more
bytes. In practice files can have additional properties such as one or
more \emph{file names}, a \emph{creation date}, a \emph{last modification date},
\emph{last access data}, and so on. Many systems also have a way of
specifying the file's \emph{type}, or the kind of information that is
stored inside the file. On Windows and Unix the file type is
inferred from the file's extension---a file named
\emph{FOOBAR.JPG} is assumed to be a JPEG digital image. But using
extension to infer file type is not universal: the HTTP protocol sends
the MIME file type along with the file length in the HTTP header when
a file is downloaded over the web.

Mass storage systems can only read or write complete blocks, so the
file system may also have to buffer data between the application
program and the drive. This means that information on the disk can
also be found in the computer's memory. This can become a privacy
problem, as the data can remain in memory long after it is erased from
the drive.


\subsection{Historical Background}
In the 1950s engineers at IBM devised a method for storing digital
information on a rotating ferromagnetic disc. As the disk spun a pair
of read/write heads (one for the top side, one for the under side)
could be moved to one of several set distances from the center of the
disk. Each surface of the disk was thus divided into a set of stacked
concentric tracks, called \emph{cylinders}, each divided into a set of
adjacent sectors. The original IBM 350 had 50 spinning 24-inch that
could store a total of 5 million bits, whereas a modern
hard drive might have two spinning platters and store a 2~TB, but the
underlying principal remains the same. 


\sgraphic{ch-fs/BRL61-IBM_305_RAMAC}{An IBM 305 RAMAC computer system at U.S. Army Red River
  Arsenal, with two IBM 350 disk drives in the foreground. Each IBM
  350 consists of fifty 24-inch diameter disks, creating 100 recording
  surfaces, each with 100 tracks, each track able to hold 100 5-bit
  characters.\cite{ibm-350}} 

 \twofigures{.5\textwidth}{ch-fs/Cylinder_Head_Sector}{The structure
   of a traditional hard drive consists of multiple platters, with
   each platter having two read/write heads. The surface of each
   platter is divided into concentric tracks, with each track divided
   into a number of sectors. The set of all tracks on all of the
   platter surfaces the same distance from the center hole are
   referred to as a cylinder, allowing each sector to be identified by
   a Cylinder, Head, Sector (CHS) address. Modern hard drives store more sectors on
 the outer tracks than the inner tracks so that data is recorded at a
 constant areal density. As a result, these drives refer to each
 sector by a Logical Block Address (LBA), rather than by
 CHS.}{.5\textwidth}{ch-fs/cd}{The data on an optical disc is arranged
   as a series of blocks in a single spiral, with information recorded
   at a constant linear density. Blocks are referred to by their
   Logical Block Address. CD-ROM (Compact Disc Read Only Memory) media
   is manufactured with its data; CD-R (Compact Disc-Recordable) can
   be recorded by users, but only once; CD-RW (Compact
  Disc-ReWritable) media can be erased and re-recorded.\textbf{TK: Draw Spiral}}


While disks turned out to be cost-effective  for storing large
amounts of information, they require that information to be broken up
into identically sized blocks, each stored at a
specific location. Requiring users to deal with this level of detail
would be unworkable. Instead, computers provide facilities for
assigning labels to sequences of sectors. The first use of the early
disk drives was to replace cardboard file boxes of punched cards that
were used to programs and data, so it was only natural that those
sequences of sectors were called \emph{files} as well. We use the same
terminology today.

Early disk systems enumerated each sector with the specific cylinder,
head and sector (CHS) that was used to access it. This approach gave
computer designers a great deal of control over the precise storage of
data, but also greatly complicated the design of software. The biggest
complication was something called \emph{bad block management}\index{bad block management}---how
the computer responded when disk sectors did not perform reliably.
Computer systems were made faster and more reliable by moving bad
block management into the drive itself. The interface was made
simpler by having the computer refer to blocks by a single
\emph{logical block address} (LBA), generally an integer greater than
or equal to 0, and allowing the drive to map the LBA to a specific
location on the media. 

Remember that files are an \emph{abstraction} that
was created for the purpose of managing data. There is nothing
inherent in the design of computers, operating systems or mass storage
devices that requires the use of files. A raw disk can be used as
virtual memory \emph{backing store} or as a storage system for a
database. Instead of stored as a sequence of bytes in a file, data can be stored as
objects that are persisted in memory, or as BLOBs in a database.

\index{Cylinder Head Sector}
\index{CHS|see {Cylinder Head Sector}}
\index{Logical Block Address}
\index{LBA|see {Logical Block Address}}

\subsection{FAT---A simple file system from the 1980s}
``FAT'' is a simple file system developed by
  Microsoft in the 1980s for use with the original IBM Personal
  Computer. FAT is an acronym that stands for File Allocation Table, an array of integers
  that is used to determine if a certain block of storage is free or
  in use. There are three primary versions of
  FAT---FAT12, FAT16 and FAT32---the primary difference being whether
  the integers in the table are 12, 16 or 32-bits. 

The integers in the FAT don't refer to individual blocks. Instead,
they refer to \emph{clusters}. In FAT, a
  \emph{cluster} is a contiguous set of 1, 2, 4, 8 or more disk
  blocks, the number being determined by the file system's
  \emph{cluster size}. (The cluster size is a per-file system
  parameter that is established when the media is formatted.)
  
The definitive specification of the FAT file system is
  the \emph{Microsoft Extensible Firmware Initiative FAT32 File System
    Specification}, rev. 1.03, Dec 6, 2000\cite{microsoft-efi }\footnote{FAT12
  and FAT16 were developed for floppy disks and had many significant
  limitations---most notably, file names could only consist of eight
  upper-case letters or numbers, a period, and then a three-character
  extension. These so-called ``8.3 filenames'' were very difficult to
  work with. The major innovation of FAT32 was a technique that
  Microsoft developed that allowed long file names to be represented
  in a manner that was invisible to legacy systems that still ran the
  old DOS systems. As a result, every file on a FAT32 file system can
  have two names---a long name with mixed case, and a shorter 8.3 name
  with only uppercase letters. Today most systems will allow long file
  names even on media formatted as FAT12 and FAT16.}

\subsection{Flash, Solid State Drives, and the Flash Translation Layer}

\emph{TK: Explain how Flash and SSDs, and the FTL}

\subsection{Partitioning and Volume Management}

Although a file system can be stored directly on the drive, with the
file sector of the drive being used to store the first sector of the
file system, this is not commonly done. Instead, the first 
sector is used to store a \emph{disk label} and  \emph{partition
  table} that provides the media with a unique identifier and describes the
locations of the file systems on the media. Advantages of disk labels
and partition tables include:
\begin{itemize}
\item Partitions allow a single physical device can contain multiple file systems.
\item Partitions can identify specific regions of the disk as reserved
  or encrypted, so that the operating system doesn't inadvertently
  damage them.
\item The device label allows the operating system reference the media
  by name, rather than by location such as the interface or bus. This
  allows computer hardware to be reconfigured without having to update
  operating system configuration.
\end{itemize}

Two commonly used partitioning schemes are the \emph{Master Boot
  Record} (MBR) and the \emph{GUID Partition Table} scheme. We
describe the MBR in \secref{sec:mbr} below; for information on GUID
partitioning please see the list of references at the end of this
chapter.

The term \emph{physical volume} is used variously to describe a
physical disk, a partition on a physical disk, or a Logical Unit
Number (LUN) of a storage system.  Physical volumes can be used
directly to hold a file system or can be grouped together with a
Logical Volume Management (LVM) system. An LVM can group multiple
physical volumes together in to a single physical volume that is large
or more reliable than the volumes that it built from. Volume managers
can also implement \emph{snapshots} through the use of
\emph{copy-on-write}.

\subsection{File Systems of Interest}
There are a many different kinds of file systems in use on
modern computer systems:
\begin{description}
\item[Disk file systems] organize files and directories on
  block-oriented storage systems. 
\item[Memory file systems] implement a file abstraction in
  memory. Such systems can provide for increased performance when
  compared to using a conventional file system on a simulated block
  device. One of the most common examples of a memory file system is tmpfs\cite{Snyder90tmpfs:a}.
\item[Distributed file systems] allow a computer to access
  information on remote servers as if it is stored
  locally. Distributed file systems are forensically interesting
  because many use local storage to cache information from the remote
  servers. Analyzing local storage can therefore give clues as to what
  was accessed remotely, and when it was accessed. Examples of
  distributed file systems include Sun's Network File System
  (NFS)\cite{Sandberg85designand,Pawlowski00thenfs} and Microsoft's
  Common Internet File System (CIFS)\cite{ms-cifs}.
\item[Virtual file systems] use the file and directory abstraction to
  make it easy to access other information. For example, the Linux
  |/dev| file system is used to access devices through the file
  system, the |/sys| file system is used to access features within
  the system kernel, and the |/net| file system accesses the
  automounter. Virtual file systems are not typically of interest in
  MEDEX because they do not leave residual information on a storage
  device. However, virtual file systems are relevant in malware
  analysis and intrusion response.
\end{description}

As this chapter is written, the following file systems are of general
interest. The number after each file system is date that the file
system became made generally usable:
\begin{description}
\item[FAT12, FAT16 and FAT32 (1980)] file systems developed by Microsoft for use with
  DOS and early versions of Windows. 
  
\item[HFS, HFS+ (1985)] the Hierarchical File System, developed by Apple
  Computer and introduced with the first Macintosh hard
  drive. Whereas most file systems of the time used tables and arrays to store
  information, HFS and HFS+ use b-trees.
\item[NTFS (1993)] the New Technology File System, developed by
  Microsoft for use with Windows NT. 
\item[EXT2/3/4 (1993)] The extended file system, developed for use with Linux systems.
\item[exFAT (2007)] a modification of the FAT file system designed to
  support large files and optimized for use on flash drives.
\item[YAFFS, YAFFS2 (2002)] ``Yet another flash file system,'' a file
  system specifically designed for use with NAND flash chips found in
  cell phones. Unlike other file systems, YAFFS2 specifically adapts
  to the requirement that flash pages be cleared before they can be
  re-written. It also handles wear-leveling and garbage collection.
  YAFFS2 gained popularity through its use in Android, although it is
  increasingly being replaced through the use of proprietary flash
  translation layers (FTLs).
\end{description}

SleuthKit version 4.1 provides read-only support for all of the file
systems listed above. Read-write support for the file systems is
inconsistent, with most operating systems supporting FAT and NTFS,
but support for others being inconsistent.

Confusingly, the phrase \emph{file system} is used ambiguously to
describe both the organization of data on a mass storage device and
the code that implements the file abstraction. Thus, are multiple FAT
implementations, only some of which are authored by
Microsoft. Different file system implementations are supposed to be
mutually compatible, but because of the complexity inherent in
creasing a file system implementation, incompatibilities inevitability
emerge.

Any computational storage device or storage abstraction can be used to
virtualize and contain any other storage device. That is, a file can
be stored in a file system, but a file system can also be created and
stored inside a file (this is essentially what a disk image is). For
example, it is possible to create a USB drive that boots a copy of
Linux but also functions under Windows: The Linux EXT file system is
stored inside a rather large file in an outer FAT32 file system.

\subsection{Encrypting File Systems}

Adding to the complexity of the is \emph{encryption}, which can be
applied at the interface between any of these abstractions. Encryption
can be performed in the storage device itself (as in the case of an
encrypting hard drive), in the disk driver, in the logical volume
management system, in the file system, or at the application level.

\emph{TK: More to come}


\section{Exploring the GEN1 SD Camera Card}
In this section we will explore the contents of an SD camera card
created in 2009 with a Canon PowerShot SD800IS camera. The card is called NPS-2009-CANON2.

\begin{figure}
\caption{A conceptual view of NPS-2009-CANON2\label{nps-2009-canon2-conceptual}}
\end{figure}

To create the data for this section, we started with a 32MB camera
card and cleared every addressable sector by overwriting that sector's
content with NULL bytes. You can do this
easily with the program in \figref{overwrite}.

\lstinputlisting[caption=\textbf{clear.py}: A simple program to clear a disk.]{ch-fs/clear.py}
\begin{figure}
\begin{lstlisting}
\end{lstlisting}
\caption{}\label{overwrite}
\end{figure}

After the card was cleared, we put it into the PowerShot, initialized
the card, and took 36 photos. We then removed the card from the
camera and placed it in a Linux-based computer, where the SD card
appeared as a virtual disk drive. In order to make a copy of the drive
data it is necessary to know the drive name that the Linux system
assigns. For example, if the drive appears as |/dev/sde|, then the
data can be copied off with this Linux  command:


\begin{code}
$ (@ \hl{sudo dd if=/dev/sde of=nps-2009-canon2-gen1.raw conv=noerror,sync} @)
\end{code} 
%$ 

The dd command copies blocks of data from the input file (\emph{if=})
to the output file (\emph{of=}). Two conversion options are
specified: \emph{noerror} tells the \emph{dd} command to continue even
if it encounters an error, and \emph{sync} tells the program to keep
the output stream synchronized with the input stream in the event of
an error by writing blocks filled with NULLs.  

When we were finished imaging the card we took it out of the Linux
computer and put it back in the camera. Next we used the camera's
interface to delete some photographs and then took some more. Then we
imaged the card a second time, creating the ``generation 2'' disk
image. This process was repeated a total of six times. By comparing
the different disk images it's possible to understand how the Camera's
firmware manages the files and directories stored on the camera card.

For the remainder of this section we'll work with just the first
generation image, which will call GEN1. You can download that file
from \url{http://digitalcorpora.org/nps-2009-canon2-gen1.raw}.


\figref{nps-2009-canon2-conceptual} shows a conceptual view of
GEN1's storage. The card has a Master Boot Record in its
first sector (block 0) which has two slots: slot 1 is an unallocated
region between blocks 0 and 50 (including, somewhat confusingly, the
master boot record itself). Slot 2 is a DOS FAT16 file system that
occupies blocks 51 through 60799. The FAT file system contains its own
structures, including a \emph{Boot Sector Structure} that describes the
file system, a \emph{root directory}, \emph{subdirectories},
\emph{files}, and finally a \emph{file allocation table} that both
describes which sectors belong to which file and indicates which
sectors are free and available for new files. We'll discuss each of
those in the following section.

\subsection{The Master Boot Record (Partition Table)}\label{sec:mbr}

The Master Boot Record, more commonly known as the MBR, occupies the first
sector of a hard drive used on most Windows-based computers. When the
computer starts up the Basic Input/Output
System (BIOS) loads these 512 bytes into the start of 
memory and jumps to location 0. Typically the MBR contains a short
program that loads more sectors from the hard drive into memory and
runs them; this second boot loader loads the operating system and runs
it.

\begin{table}
\begin{minipage}{\textwidth}
\caption{Structure of the Master Book Record.\protect\footnote{From Wikipedia, \url{http://en.wikipedia.org/wiki/Master_boot_record}}}\label{mbr}
\begin{tabular}{|>{\tt}c|>{\tt}c|c|c|c|}
\hline
\multicolumn{2}{|c|}{\bf Address} & \multicolumn{2}{c|}{}                              & \\
\cline{1-2} \bf Hex & \bf Dec         & \multicolumn{2}{c|}{\multirow{-2}{*}{\bf Description}} & \multirow{-2}{*}{\bf Size in bytes}\\
\hline
+000h & +0   & \multicolumn{2}{c|}{Bootstrap code; extended information} & 446 \\
\hline
\hline
+1BEh & +446 & \multicolumn{2}{c|}{Partition entry \#1} & 16 \\
\hline
+1CEh & +462 & \multicolumn{2}{c|}{Partition entry \#2} & 16 \\
\hline
+1DEh & +478 & \multicolumn{2}{c|}{Partition entry \#3} & 16 \\
\hline
+1EEh & +494 & \multicolumn{2}{c|}{Partition entry \#4} & 16 \\
\hline
+1FEh & +510 & 55h & & \\
\cline{1-3}
+1FFh & +511 & AAh & \multirow{-2}{*}{Boot Signature} & \multirow{-2}{*}{2} \\
\hline
\hline
\multicolumn{4}{|r|}{\textbf{Total size: $\bf 446 + (4\times16) + 2 $}} & \textbf{512}\\
\hline
\end{tabular}
\end{minipage}
\end{table}


\begin{table}
\caption{Structure of the 16-byte partition
  entry\protect{footnote{From Wikipedia,
      \url{http://en.wikipedia.org/wiki/Master_boot_record}}}\label{mbr:partition}}
\begin{tabular}{|>{\tt}c|c|l|}
Offset & Length & Description \\
\hline
+0h & 1 & Status; |80h|:active; |00h|: inactive \\
+1h & 3 & CHS address of first sector in partition \\
+4h & 1 & Partition Type Code \\
+5h & 3 & CHS address of last sector in partition\\
+8h & 4 & LBA address of first sector in partition \\
+Ch & 4 & Number of sectors in partition \\
\hline
+0h & 16 & Total number of bytes in entry \\
\hline
\hline
\end{tabular}
\end{table}


The basic MBR (\tabref{mbr}) provides for four partitions, each
described by a 16-byte partition entry record. The record includes a byte
indicating if it is active or not, the start of the partition and the
partition's length.  Originally the start and end were encoded as a 
3-byte CHS (Cylinder, Head, Sector) triplet. Today the CHS entries are
ignored and the partition is described with a pair of 32-bit LE
numbers conveying the Logical Block Address (LBA) of the first sector
and a sector count. Because blocks
are assumed to be 512 bytes, this scheme allows for a
maximum media size of $512 \times 2^{32}=2\textrm{TiB}$ in storage.

If you review the Wikipedia page you will see that no less than six
different MBRs have been developed and deployed since
MBR records were introduced by IBM PC DOS 2.0 in 1983. All of these
systems store the bootstrap code at location 0, the first four
partition entries starting at location |1BEh|, and have a boot
signature in the last two blocks of the sector. This consistency 
provides for backwards compatibility, allowing each 
generation of disk utilities and BIOS drivers to make sense of
whatever data they might find on a mass storage device.  Modern
computers use a new partitioning scheme called the GUID Partition
Table (GPT), but even these systems include something called
a ``Protective MBR'' that allocates the entire drive to a partition of
type |EEh|. As its name implies, this partition protects the GPT disk in the
event that the user attempts to mount it on a system that does not
understand GPT partitioning: instead of inadvertently overwriting the
GPT partition, the non-GPT system will leave it alone, since the
entire media is in use by a partition type that the non-GPT system does not understand.

\subsection{Viewing the MBR}

You can display the contents of the MBR by viewing a hex dump of the
first sector:

\begin{code}
$ (@ \hl{xxd -len 512 nps-2009-canon2-gen1.raw} @)
0000000: fa33 c08e d0bc 007c 8bf4 5007 501f fbfc  .3.....|..P.P...
0000010: bf00 06b9 0001 f2a5 ea1d 0600 00be be07  ................
0000020: b304 803c 8074 0e80 3c00 751c 83c6 10fe  ...<.t..<.u.....
0000030: cb75 efcd 188b 148b 4c02 8bee 83c6 10fe  .u......L.......
0000040: cb74 1a80 3c00 74f4 be8b 06ac 3c00 740b  .t..<.t.....<.t.
0000050: 56bb 0700 b40e cd10 5eeb f0eb febf 0500  V.......^.......
0000060: bb00 7cb8 0102 57cd 135f 730c 33c0 cd13  ..|...W.._s.3...
0000070: 4f75 edbe a306 ebd3 bec2 06bf fe7d 813d  Ou...........}.=
0000080: 55aa 75c7 8bf5 ea00 7c00 0049 6e76 616c  U.u.....|..Inval
0000090: 6964 2070 6172 7469 7469 6f6e 2074 6162  id partition tab
00000a0: 6c65 0045 7272 6f72 206c 6f61 6469 6e67  le.Error loading
00000b0: 206f 7065 7261 7469 6e67 2073 7973 7465   operating syste
00000c0: 6d00 4d69 7373 696e 6720 6f70 6572 6174  m.Missing operat
00000d0: 696e 6720 7379 7374 656d 0000 0000 0000  ing system......
00000e0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00000f0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
0000100: 0000 0000 0000 0000 0000 0000 0000 0000  ................
0000110: 0000 0000 0000 0000 0000 0000 0000 0000  ................
0000120: 0000 0000 0000 0000 0000 0000 0000 0000  ................
0000130: 0000 0000 0000 0000 0000 0000 0000 0000  ................
0000140: 0000 0000 0000 0000 0000 0000 0000 0000  ................
0000150: 0000 0000 0000 0000 0000 0000 0000 0000  ................
0000160: 0000 0000 0000 0000 0000 0000 0000 0000  ................
0000170: 0000 0000 0000 0000 0000 0000 0000 0000  ................
0000180: 0000 0000 0000 0000 0000 0000 0000 0000  ................
0000190: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00001a0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00001b0: 0000 0000 0000 0000 0000 0000 0000 0001  ................
00001c0: 1400 0403 60da 3300 0000 4ded 0000 0000  ....`.3...M.....
00001d0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00001e0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
00001f0: 0000 0000 0000 0000 0000 0000 0000 55aa  ..............U.
$ 
\end{code}

Decoding is not difficult, but can be time consuming. Instead of
manually attacking the hex values, it is more effective to write a
program that does this work for you. Listing~\ref{mbrdecode} the start
of such a program in Python. This program  will open
up the disk image, read the sector into memory, and then print the
fields. 

\begin{figure}
\lstinputlisting[caption=The start of a python program to display the
  Master Boot Record.]{ch-fs/mbrdecode.py}\label{mbrdecode}
\end{figure}

Finally, you can view the contents of the MBR using the SleuthKit's |mmls| command:


\begin{code}
C:\ (@ \hl{mmls nps-2009-canon2-gen1.raw} @)
\end{code}

Use the \texttt{-h} option to display all of the options that your
version of the |mmls| command supports.

Example: Finally, the MBR can be analyzed with a program of your own
creation. 


The first block of a FAT file system contains a \emph{Boot Sector
  Structure} that describes the file system's parameters, including
the sector size, the cluster size, the number of reserved sectors, the
number of File Allocation Tables, and so on. The layout of this
structure is described in Microsoft's FAT specification; you can also
find it in the SleuthKit file |sleuthkit/tsk3/fs/tsk_fs.h|. The first
few lines of the SleuthKit structure are show in \figref{BSS}.

\begin{figure}
\begin{lstlisting}[caption={The first few bytes of the Boot Sector
      Structure, the first sector of a FAT file system. From
      Sleuthkit's \texttt{tsk\_fs.h}.\label{BSS}}]
/*
 * Boot Sector Structure for TSK_FS_INFO_TYPE_FAT_12,
 * TSK_FS_INFO_TYPE_FAT_16, and TSK_FS_INFO_TYPE_FAT_32
 */
    typedef struct {
        uint8_t f1[3];
        char oemname[8];
        uint8_t ssize[2];       /* sector size in bytes */
        uint8_t csize;          /* cluster size in sectors */
        uint8_t reserved[2];    /* number of reserved sectors for boot sectors */
        uint8_t numfat;         /* Number of FATs */
        uint8_t numroot[2];     /* Number of Root dentries */
        uint8_t sectors16[2];   /* number of sectors in FS */
        uint8_t f2[1];
        uint8_t sectperfat16[2];        /* size of FAT */
        uint8_t f3[4];
        uint8_t prevsect[4];    /* number of sectors before FS partition */
        uint8_t sectors32[4];   /* 32-bit value of number of FS sectors */

        /* The following are different for fat12/fat16 and fat32 */
        ...
\end{lstlisting}
% \caption{}
\end{figure}

The FAT file system's 

Because the FAT file system begins in sector 51, the number ``51''
must be added to all internal references.

occu; A listing of
that camera card appears in Figure Tk. Various sectors on the card are
used to store the root directory, a subdirectory ``DCIM'', and
directory entries for the 35 JPEG
images named XXXX through XXXX. Most of the sectors on the card are
used to store the JPEG images themselves. But the card also contains a
significant amount of data that not visible when the card is
inserted into a laptop: there are deleted JPEGs and deleted directory
entries. Some of the deleted JPEGs exist in their entirity and can be
easily recovered using the proper tools. Others exist as fragments and
can only be recovered with difficulty. 


\section{Exercise: Windows - Creating and Testing FAT32 Disks}

This exercise is designed to help you understand how file systems
store information and the opportunities for retaining
privacy-sensitive information that is not visible to the user. 

This exercise will be done with a \emph{virtual disk}. Like a physical
mass storage device, a virtual disk consists of a set of numbered data
blocks. But instead of storing those blocks directly in on a mass
storage device, the blocks are stored in another file. The operating
system treats the virtual disk like a physical drive: it can be
formatted, files can be copied to it, and so on. But we can also
access the underlying file that holds the virtual disk. This makes it
easier to inspect the individual data blocks.

We will use the Windows |DISKPART| command to create and manage virtual
disks. |DISKPART| is a command-line tool that needs to run as
Administrator.

We will be using these commands:

\begin{tabular}{>{\tt}ll}
\hline
help partition & shows partition command available\\
create vdisk & Creates a virtual disk \\
list disk & Shows available disks \\
list vdisk & Shows detailed information about the available VDisks\\
list partition & Shows available partitions \\
\hline
\end{tabular}

We will create a text file on the virtual disk that has a sensitive file
name and file contents. Next we will take a screen shot and save it on
the computer's hard drive as a JPEG. We will then delete the text file
and empty the trash. Finally we will inspect the disk image and see if
we can find the text file and the screen shot.


\begin{enumerate}


\item Click the Start button, type |diskpart| into the search field,
and click on the |diskpart| program icon.
\item The User Account Control will ask you to verify that you want to
run the DiskPart, a program that can make ``changes to the computer.''
Click ``Yes.''  The |diskpart.exe| window should appear.
\item If you haven't done so already, right-click on the window's
titlebar and select ``Properties.'' Click on the Layout tab and change
the ``Screen Buffer Size'' to 9999. This will allow you to scroll
backwards and see the entire history of your DISKPART session.
\item Type |help| to see the list of commands that the DISKPART
command supports. You may need to make the window larger.

\item Create a 16MB virtual disk with the command:

\begin{code}
DISKPART> (@ \hl{create vdisk file="C:\textbackslash{}disk1.vhd" maximum=16} @)
\end{code}

\item Attach the disk you just created:
\begin{code}
DISKPART> (@ \hl{attach vdisk} @)
\end{code}

\item Verify that the disk is attached:
\begin{code}
DISKPART> (@ \hl{list disk} @)
...
DISKPART> (@ \hl{list vdisk} @)
\end{code}

\item Now we need to create a partition, assign a letter to that
partition, and format the drive. We will call this drive K: and format
it with FAT. 
\begin{code}
DISKPART> (@ \hl{create partition primary} @)
DISKPART> (@ \hl{assign letter=k} @)
DISKPART> (@ \hl{format fs=fat label="WORK"} @)
\end{code}
\end{enumerate}

At this point we have a 16MB virtual disk attached to the computer as
drive K:. The drive's contents are stored in the file |C:\disk1.vhd|.

Lastly, we want to put a file on this disk. For test purposes we are
going to use a small file with a distinctive file name and file
contents.

\begin{enumerate}[resume]
\item Run the windows NotePad program by clicking the Start program,
typing ``Notepad'' into the search field, and clicking on the icon.

\item Type this text into the document:  ``The phone number is
202-555-1212.'' You can use your own phone number and add additional
information if you wish.

\item Select ``File/Save As'' and save the file on the WORK (K:) drive
with the name ``file-name-example-0001.txt''. 

\item Close the Notepad program.

\item Now we will detach the virtual disk:

\begin{code}
DISKPART> (@ \hl{detach vdisk} @)
\end{code}

\end{enumerate}

\subsection{Looking for the files}
The 

\section{File Deletion and Deleted File Recovery}\label{deleted_file_recovery}
Different file system implementations delete files in different ways.

Traditionally, file systems simply \emph{unlinked} files---the pointer
to the file was removed from the directory, and the blocks associated
with the file were returned to the free list.


\section{Exploiting File System Metadata}
File system metadata can be used to determine usage. 
\cite{dfrws2011:JonathanGrier}

\section{Opportunities for hiding data in File Systems}

Information can be hidden in a file system by storing data in blocks
that are allocated but not used to hold content\cite{dfrws2005:KnutEcksteinAndMarkoJahnke}. 


\section{Further Reading}
\subsection{Books}
\subsection{Articles}
\subsection{Wikipedia}
As of this writing, the following wikipedia pages provide excellent
insight to the concepts mentioned in this chapter:

\begin{description}
\item[\href{http://en.wikipedia.org/wiki/Copy-on-write}{Copy-on-write}]
\item[\href{http://en.wikipedia.org/wiki/Logical_Unit_Number}{Logical
    Unit Number}] Something about the LUN
\item[\href{http://en.wikipedia.org/wiki/Logical_volume_management}{Logical
    Volume Management}]
\item[\href{http://en.wikipedia.org/wiki/Snapshot_(computer_storage)}{Snapshot
    (Computer Storage)}]
\end{description}

\section{Terminology}
\sgraphic{art/diskpart-1}{The Windows diskpart command is used to create and
  manage physical and virtual disks.}


Allocated

Blocks

Carving

Clusters

Deleted

File Allocation Table

Free List

inode

Hard Link

Symbolic Link

Master File Table

Overwritten

TRIM Command

Undelete

Unlink




% LocalWords:  virtualize
